{"abi":[{"type":"function","name":"computeAddress","inputs":[{"name":"bytecode","type":"bytes","internalType":"bytes"},{"name":"_salt","type":"uint256","internalType":"uint256"}],"outputs":[{"name":"","type":"address","internalType":"address"}],"stateMutability":"view"},{"type":"function","name":"deploy","inputs":[{"name":"bytecode","type":"bytes","internalType":"bytes"},{"name":"_salt","type":"uint256","internalType":"uint256"}],"outputs":[{"name":"","type":"address","internalType":"address"}],"stateMutability":"payable"},{"type":"event","name":"Deploy","inputs":[{"name":"addr","type":"address","indexed":false,"internalType":"address"}],"anonymous":false}],"bytecode":{"object":"0x608080604052346015576101d2908161001a8239f35b5f80fdfe60806040526004361015610011575f80fd5b5f3560e01c806381176c201461003457639c4ae2d01461002f575f80fd5b61016b565b346100b1576100ad610093610048366100f1565b90602081519101209060405191602083019160ff60f81b83523060601b602185015260358401526055830152605582526100836075836100c9565b905190206001600160a01b031690565b6040516001600160a01b0390911681529081906020820190565b0390f35b5f80fd5b634e487b7160e01b5f52604160045260245ffd5b601f909101601f19168101906001600160401b038211908210176100ec57604052565b6100b5565b60406003198201126100b1576004356001600160401b0381116100b157816023820112156100b1576004810135906001600160401b0382116100ec5760405192610145601f8401601f1916602001856100c9565b828452602483830101116100b157815f9260246020930183860137830101529060243590565b610174366100f1565b9060208151910134f5803b156100b1576040516001600160a01b039091168082526020917f55ea6c6b31543d8e2ec6a72f71a79c0f4b72ed0d4757172b043d8f4f4cd84848908390a1604051908152f3fea164736f6c634300081b000a","sourceMap":"1334:2648:12:-:0;;;;;;;;;;;;;;;;;","linkReferences":{}},"deployedBytecode":{"object":"0x60806040526004361015610011575f80fd5b5f3560e01c806381176c201461003457639c4ae2d01461002f575f80fd5b61016b565b346100b1576100ad610093610048366100f1565b90602081519101209060405191602083019160ff60f81b83523060601b602185015260358401526055830152605582526100836075836100c9565b905190206001600160a01b031690565b6040516001600160a01b0390911681529081906020820190565b0390f35b5f80fd5b634e487b7160e01b5f52604160045260245ffd5b601f909101601f19168101906001600160401b038211908210176100ec57604052565b6100b5565b60406003198201126100b1576004356001600160401b0381116100b157816023820112156100b1576004810135906001600160401b0382116100ec5760405192610145601f8401601f1916602001856100c9565b828452602483830101116100b157815f9260246020930183860137830101529060243590565b610174366100f1565b9060208151910134f5803b156100b1576040516001600160a01b039091168082526020917f55ea6c6b31543d8e2ec6a72f71a79c0f4b72ed0d4757172b043d8f4f4cd84848908390a1604051908152f3fea164736f6c634300081b000a","sourceMap":"1334:2648:12:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;3942:31;1334:2648;;;:::i;:::-;;;;;;;3851:19;1334:2648;;;3679:236;1334:2648;3679:236;;1334:2648;;;;;;3769:4;1334:2648;;;;;;;;;;;;;;;3679:236;;;;;;:::i;:::-;1334:2648;;3656:269;;-1:-1:-1;;;;;1334:2648:12;;;3942:31;1334:2648;;-1:-1:-1;;;;;1334:2648:12;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;1334:2648:12;;;;-1:-1:-1;;;;;1334:2648:12;;;;;;;;;;:::o;:::-;;:::i;:::-;;-1:-1:-1;;1334:2648:12;;;;;;;-1:-1:-1;;;;;1334:2648:12;;;;;;;;;;;;;;;;;-1:-1:-1;;;;;1334:2648:12;;;;;;;;;;;-1:-1:-1;;1334:2648:12;;;;;:::i;:::-;;;;;;;;;;;;;-1:-1:-1;1334:2648:12;;;;;;;;;;;;;;;;;:::o;:::-;;;;:::i;:::-;2192:498;;;;;;;;;;;;;1334:2648;;-1:-1:-1;;;;;1334:2648:12;;;;;;2192:498;;2704:12;;2192:498;;2704:12;1334:2648;;;;;","linkReferences":{}},"methodIdentifiers":{"computeAddress(bytes,uint256)":"81176c20","deploy(bytes,uint256)":"9c4ae2d0"},"rawMetadata":"{\"compiler\":{\"version\":\"0.8.27+commit.40a35a09\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"Deploy\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"bytecode\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_salt\",\"type\":\"uint256\"}],\"name\":\"computeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"bytecode\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_salt\",\"type\":\"uint256\"}],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"This is essential for Uniswap v4 hooks which require specific addresses with embedded flags WHY THIS IS NEEDED IN HARDHAT: - Uniswap v4 hooks must be deployed to addresses where the address itself encodes permissions - Foundry has built-in tools (vm.etch, deployCodeTo) for this, but we can't use them here - IMPORTANT: Zama (FHEVM) does NOT have Foundry support, so we must use Hardhat - This factory provides CREATE2 deployment capabilities in Hardhat environment HOW CREATE2 WORKS: The deployed contract address is deterministically computed as:   address = keccak256(0xff ++ factory_address ++ salt ++ keccak256(bytecode))[12:] This allows us to: 1. Pre-compute the deployment address before deploying 2. Search for a salt that produces an address with the required hook flags 3. Deploy the hook to that exact address USAGE FLOW: 1. Prepare hook bytecode with constructor args 2. Use computeAddress() to find a salt that gives valid hook address 3. Call deploy() with the bytecode and found salt 4. Hook is deployed to the pre-computed address with correct flags\",\"kind\":\"dev\",\"methods\":{\"computeAddress(bytes,uint256)\":{\"details\":\"This allows finding a valid salt before deployment\",\"params\":{\"_salt\":\"The salt to use for address computation\",\"bytecode\":\"The creation bytecode (must match what will be deployed)\"},\"returns\":{\"_0\":\"The computed deployment address CRITICAL: The bytecode MUST be exactly the same as what you'll deploy, including constructor arguments. Any difference will result in a different address. For Uniswap v4 hooks, you'll typically: 1. Loop through different salts 2. Call this function for each salt 3. Check if the returned address has the required hook flags in the right position 4. Once found, use that salt in deploy()\"}},\"deploy(bytes,uint256)\":{\"details\":\"Uses inline assembly to access the CREATE2 opcode\",\"params\":{\"_salt\":\"A unique value to influence the resulting address\",\"bytecode\":\"The creation bytecode of the contract (including constructor args)\"},\"returns\":{\"_0\":\"addr The address of the deployed contract The CREATE2 opcode takes 4 parameters: 1. value - ETH to send (callvalue()) 2. offset - where bytecode starts in memory (add(bytecode, 0x20) skips length prefix) 3. size - bytecode length (mload(bytecode) reads the length) 4. salt - the salt value for deterministic addressing\"}}},\"title\":\"DeterministicDeployFactory\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"computeAddress(bytes,uint256)\":{\"notice\":\"Computes the address where a contract would be deployed\"},\"deploy(bytes,uint256)\":{\"notice\":\"Deploys a contract using CREATE2\"}},\"notice\":\"Factory contract for deploying contracts to deterministic addresses using CREATE2\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/test/DeterministicDeployFactory.sol\":\"DeterministicDeployFactory\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"none\"},\"optimizer\":{\"enabled\":true,\"runs\":1},\"remappings\":[\":@fhevm/=node_modules/@fhevm/\",\":@openzeppelin/=node_modules/@openzeppelin/\",\":@pythnetwork/=node_modules/@pythnetwork/\",\":@uniswap/=node_modules/@uniswap/\",\":base64-sol/=node_modules/base64-sol/\",\":ds-test/=node_modules/@uniswap/v4-core/lib/solmate/lib/ds-test/\",\":encrypted-types/=node_modules/encrypted-types/\",\":erc4626-tests/=node_modules/@uniswap/v4-core/lib/openzeppelin-contracts/lib/erc4626-tests/\",\":forge-gas-snapshot/=node_modules/@uniswap/v4-periphery/lib/permit2/lib/forge-gas-snapshot/\",\":forge-std/=lib/forge-std/src/\",\":hardhat-deploy/=node_modules/hardhat-deploy/\",\":hardhat/=node_modules/hardhat/\",\":openzeppelin-confidential-contracts/=node_modules/openzeppelin-confidential-contracts/\",\":openzeppelin-contracts/=node_modules/@uniswap/v4-core/lib/openzeppelin-contracts/\",\":permit2/=node_modules/@uniswap/v4-periphery/lib/permit2/\",\":solmate/=node_modules/solmate/\",\":v4-core/=node_modules/@uniswap/v4-periphery/lib/v4-core/\"],\"viaIR\":true},\"sources\":{\"contracts/test/DeterministicDeployFactory.sol\":{\"keccak256\":\"0xe35b421c9c0ae2cff05c62d04b4e83c5b58550c1806f9ab42f0d9e9a93edc307\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://eb9ca76fa85dfa982709fdcefb858960423a2a664df6c8752a38aa7fc4701ada\",\"dweb:/ipfs/QmP47BP2GZWFgyJu4sy6caNNBPMBvuW6J6P1JG3K3KvNuj\"]}},\"version\":1}","metadata":{"compiler":{"version":"0.8.27+commit.40a35a09"},"language":"Solidity","output":{"abi":[{"inputs":[{"internalType":"address","name":"addr","type":"address","indexed":false}],"type":"event","name":"Deploy","anonymous":false},{"inputs":[{"internalType":"bytes","name":"bytecode","type":"bytes"},{"internalType":"uint256","name":"_salt","type":"uint256"}],"stateMutability":"view","type":"function","name":"computeAddress","outputs":[{"internalType":"address","name":"","type":"address"}]},{"inputs":[{"internalType":"bytes","name":"bytecode","type":"bytes"},{"internalType":"uint256","name":"_salt","type":"uint256"}],"stateMutability":"payable","type":"function","name":"deploy","outputs":[{"internalType":"address","name":"","type":"address"}]}],"devdoc":{"kind":"dev","methods":{"computeAddress(bytes,uint256)":{"details":"This allows finding a valid salt before deployment","params":{"_salt":"The salt to use for address computation","bytecode":"The creation bytecode (must match what will be deployed)"},"returns":{"_0":"The computed deployment address CRITICAL: The bytecode MUST be exactly the same as what you'll deploy, including constructor arguments. Any difference will result in a different address. For Uniswap v4 hooks, you'll typically: 1. Loop through different salts 2. Call this function for each salt 3. Check if the returned address has the required hook flags in the right position 4. Once found, use that salt in deploy()"}},"deploy(bytes,uint256)":{"details":"Uses inline assembly to access the CREATE2 opcode","params":{"_salt":"A unique value to influence the resulting address","bytecode":"The creation bytecode of the contract (including constructor args)"},"returns":{"_0":"addr The address of the deployed contract The CREATE2 opcode takes 4 parameters: 1. value - ETH to send (callvalue()) 2. offset - where bytecode starts in memory (add(bytecode, 0x20) skips length prefix) 3. size - bytecode length (mload(bytecode) reads the length) 4. salt - the salt value for deterministic addressing"}}},"version":1},"userdoc":{"kind":"user","methods":{"computeAddress(bytes,uint256)":{"notice":"Computes the address where a contract would be deployed"},"deploy(bytes,uint256)":{"notice":"Deploys a contract using CREATE2"}},"version":1}},"settings":{"remappings":["@fhevm/=node_modules/@fhevm/","@openzeppelin/=node_modules/@openzeppelin/","@pythnetwork/=node_modules/@pythnetwork/","@uniswap/=node_modules/@uniswap/","base64-sol/=node_modules/base64-sol/","ds-test/=node_modules/@uniswap/v4-core/lib/solmate/lib/ds-test/","encrypted-types/=node_modules/encrypted-types/","erc4626-tests/=node_modules/@uniswap/v4-core/lib/openzeppelin-contracts/lib/erc4626-tests/","forge-gas-snapshot/=node_modules/@uniswap/v4-periphery/lib/permit2/lib/forge-gas-snapshot/","forge-std/=lib/forge-std/src/","hardhat-deploy/=node_modules/hardhat-deploy/","hardhat/=node_modules/hardhat/","openzeppelin-confidential-contracts/=node_modules/openzeppelin-confidential-contracts/","openzeppelin-contracts/=node_modules/@uniswap/v4-core/lib/openzeppelin-contracts/","permit2/=node_modules/@uniswap/v4-periphery/lib/permit2/","solmate/=node_modules/solmate/","v4-core/=node_modules/@uniswap/v4-periphery/lib/v4-core/"],"optimizer":{"enabled":true,"runs":1},"metadata":{"bytecodeHash":"none"},"compilationTarget":{"contracts/test/DeterministicDeployFactory.sol":"DeterministicDeployFactory"},"evmVersion":"cancun","libraries":{},"viaIR":true},"sources":{"contracts/test/DeterministicDeployFactory.sol":{"keccak256":"0xe35b421c9c0ae2cff05c62d04b4e83c5b58550c1806f9ab42f0d9e9a93edc307","urls":["bzz-raw://eb9ca76fa85dfa982709fdcefb858960423a2a664df6c8752a38aa7fc4701ada","dweb:/ipfs/QmP47BP2GZWFgyJu4sy6caNNBPMBvuW6J6P1JG3K3KvNuj"],"license":"MIT"}},"version":1},"id":12}